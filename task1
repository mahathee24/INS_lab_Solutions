Hybrid Cipher: Vigenère + Columnar Transposition
This repository implements a hybrid encryption scheme that combines two classical ciphers:

Vigenère Cipher (Substitution): Each character in the plaintext is shifted based on a random keystream.
Columnar Transposition Cipher (Transposition): The substituted text is rearranged by columns based on a transposition key.
How It Works:
Encryption: The plaintext is first encrypted using the Vigenère cipher with a random keystream, followed by encryption with the Columnar Transposition cipher using a key.
Decryption: The ciphertext is decrypted by first reversing the Columnar Transposition, then decrypting the result with the Vigenère cipher using the original keystream.
This hybrid approach provides stronger encryption by combining both substitution and transposition techniques.


#
import random
import string
import numpy as np

# Helper function to generate a secure random keystream
def generate_keystream(length):
    return [random.randint(0, 255) for _ in range(length)]

# Substitution Step: Vigenère-like encryption (Byte-wise)
def vigenere_encrypt(plaintext, keystream):
    return bytes([(ord(plaintext[i]) + keystream[i]) % 256 for i in range(len(plaintext))])

def vigenere_decrypt(ciphertext, keystream):
    return ''.join([chr((ciphertext[i] - keystream[i]) % 256) for i in range(len(ciphertext))])

# Transposition Step: Columnar Transposition Cipher
def columnar_transposition_encrypt(text, key):
    num_cols = len(key)
    num_rows = -(-len(text) // num_cols)  # Ceiling division
    matrix = [['' for _ in range(num_cols)] for _ in range(num_rows)]

    # Fill the matrix row-wise
    index = 0
    for i in range(num_rows):
        for j in range(num_cols):
            if index < len(text):
                matrix[i][j] = text[index]
                index += 1

    # Read columns in key order
    sorted_key = sorted(list(enumerate(key)), key=lambda x: x[1])
    encrypted_text = ''.join(matrix[row][col[0]] for col in sorted_key for row in range(num_rows) if matrix[row][col[0]])
    return encrypted_text

def columnar_transposition_decrypt(text, key):
    num_cols = len(key)
    num_rows = -(-len(text) // num_cols)  # Ceiling division
    matrix = [['' for _ in range(num_cols)] for _ in range(num_rows)]

    sorted_key = sorted(list(enumerate(key)), key=lambda x: x[1])
    col_lengths = [num_rows] * (len(text) % num_cols) + [num_rows - 1] * (num_cols - len(text) % num_cols)

    # Fill the matrix column-wise
    index = 0
    for col, _ in sorted_key:
        for row in range(col_lengths[col]):
            if index < len(text):
                matrix[row][col] = text[index]
                index += 1

    # Read row-wise to decrypt
    decrypted_text = ''.join(matrix[row][col] for row in range(num_rows) for col in range(num_cols) if matrix[row][col])
    return decrypted_text

# Hybrid Encryption
def hybrid_encrypt(plaintext, transposition_key):
    keystream = generate_keystream(len(plaintext))
    substituted_text = vigenere_encrypt(plaintext, keystream)
    transposed_text = columnar_transposition_encrypt(substituted_text.decode('latin-1'), transposition_key)
    return transposed_text, keystream

# Hybrid Decryption
def hybrid_decrypt(ciphertext, keystream, transposition_key):
    transposed_text = columnar_transposition_decrypt(ciphertext, transposition_key)
    original_text = vigenere_decrypt(transposed_text.encode('latin-1'), keystream)
    return original_text

# Example Usage
plaintext = "HYBRIDCIPHERSARESECURE!"
transposition_key = "SECURITY"

# Encrypt
encrypted_text, keystream = hybrid_encrypt(plaintext, transposition_key)
print("Encrypted Text:", encrypted_text)

# Decrypt
decrypted_text = hybrid_decrypt(encrypted_text, keystream, transposition_key)
print("Decrypted Text:", decrypted_text)


task 1 code  in google collab:-(https://colab.research.google.com/drive/1Q0JFUI6yM1ouSdsc6MGaA0FouB4Zn5hO#scrollTo=zMSreJIiZ9fs)
